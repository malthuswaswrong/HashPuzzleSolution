# HashPuzzleSolution

This was a project to test if it is viable to generate random SHA256 hashes to give a client "busy work" to prevent flooding a server and require an approximate "time to finish" based on difficulty.

It sort of works, but it's way too "rude" for what I'm intending.  I wanted to use this as the core of a game where players complete "tasks" by generating hashes and when they found the "answer" they were allowed into the next part of the puzzle.

My first attempt was at a perfect match of order without gaps.
* 2,3,4,5 must all exist in order without gaps in array 0,1,2,3,4,5,6,7,8

The difficulty of this strategy scales too quickly.

My next attempt was to simply match existence at any position in the array
* 2,3,4,5 is "good" against array 3,2,6,4,7,5,1,9,8

This worked better as you could control the scaling better

Testing on my machine showed a search of random N matches led to T time
| matches | time |
| ------------- | ------------- |
| 1 | <1 (ms) |
| 2  | <1 (ms) |
| 3  | ~2 (ms) |
| 4  | ~5 (ms) |
| 5  | ~367 (ms) |
| 6  | ~968 (ms) |
| 7  | ~21 (sec) |
| 8  | ~1 (min) |
| 9  | ~2 (min) |

But the whole concept is flawed for my purposes because it's not cool to burn 100% of a CPU core on someone's computer just to simulate a difficult task in a game.  Regardless of the flaws I wanted to preserve my work and make it available to anyone who is interested.

## 2022-07-15 ##
I just thought of an interesting way to change this to make it more useful.  All the work is done on the client.  The client controls the search speed and maximum "token cache" they want to search for.  Once they've hit the max number of tokens the client will stop searching.  Instead of the target value being randomly generated by the server and given to the client, it is instead generated on the client based on time or some other deterministic attribute.  Then when it comes time to spend the token on the server the deterministic attribute is transmitted to the server along with the random bytes and the server simply checks the work after determing that the assumption is correct (Ex: checking that the time used to generate the search key was within the allowed limit).

This allows tokens to expire.  The algorithum could be tunes so a fair player could generate something like 10 tokens an hour, but a cheater or someone setting the settings at max could only generate 1000 an hour, which is still a good flood control and raises the cost for bad actors.

In a message board scenario users could mine tokens and gift them as rewards to other posters when they like the post.  Encouraging good posters to post more for free.   A type of token economy can be established.  With the algos being open source people could make their own clients.  It shouldn't matter if the algo is good.
